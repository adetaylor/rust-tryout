# static

This crate shows examples of definition of thread-safe mutable static variables. The different approaches are as follows:

- [atomic_safe](./src/bin/atomic_safe.rs) -- uses the `arc_swap crate`. This is the cleanest efficient (lock-free) solution.
- [atomic_unsafe1](./src/bin/atomic_unsafe1.rs) -- uses `AtomicUsize` and some unsafe code to coerce a raw pointer to `usize`. This is an efficient lock-free solution but requires a bit of unsafe code. The base for this example was generated by ChatGPT (see [ChatGPT_How_to_Create_Lock_Free_Thread_Safe_Static_Variable_in_Rust.md](./ChatGPT_How_to_Create_Lock_Free_Thread_Safe_Static_Variable_in_Rust.md)). The generated code had placeholders and compilation errors that had to be fixed manually.
- [atomic_unsafe2](./src/bin/atomic_unsafe2.rs) -- uses `AtomicPtr` and some unsafe code. This is an efficient lock-free solution but requires a bit of unsafe code. The base for this example was generated by ChatGPT (see [ChatGPT_How_to_Create_Lock_Free_Thread_Safe_Static_Variable_in_Rust.md](./ChatGPT_How_to_Create_Lock_Free_Thread_Safe_Static_Variable_in_Rust.md)). The generated code had placeholders and compilation errors that had to be fixed manually. This example's structure was used in the other examples.
- [mutex1](./src/bin/mutex1.rs) -- uses a `Mutex` and a `RefCell`. This is an inefficient solution due to locking.
- [mutex2](./src/bin/mutex2.rs) -- simplification of the previous example with the `Mutex` directly wrapping the data structure without the use of a `RefCell`. This is an inefficient solution due to locking.
- [mutex2_macro](./src/bin/mutex2_macro.rs) -- same as the previous example but using the lazy_static macro instead of the `sync::Lazy` struct from the `once_cell` crate. This is an inefficient solution due to locking.

***Note:** Solutions using `RwLock`* instead of `Mutex` could be constructed but they would still be inefficient due to locking.
